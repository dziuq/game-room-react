import{isKeyframesTarget}from"../../../animation/utils/is-keyframes-target.js";import{invariant}from"../../../utils/errors.js";import{transformPropOrder}from"../../html/utils/transform.js";import{findDimensionValueType}from"../value-types/dimensions.js";import{isBrowser}from"../../../utils/is-browser.js";import{number}from"../../../value/types/numbers/index.js";import{px}from"../../../value/types/numbers/units.js";const positionalKeys=new Set(["width","height","top","left","right","bottom","x","y","translateX","translateY"]),isPositionalKey=e=>positionalKeys.has(e),hasPositionalKey=e=>Object.keys(e).some(isPositionalKey),isNumOrPxType=e=>e===number||e===px,getPosFromMatrix=(e,t)=>parseFloat(e.split(", ")[t]),getTranslateFromMatrix=(e,t)=>(s,{transform:r})=>{if("none"===r||!r)return 0;const a=r.match(/^matrix3d\((.+)\)$/);if(a)return getPosFromMatrix(a[1],t);{const t=r.match(/^matrix\((.+)\)$/);return t?getPosFromMatrix(t[1],e):0}},transformKeys=new Set(["x","y","z"]),nonTranslationalTransformKeys=transformPropOrder.filter((e=>!transformKeys.has(e)));function removeNonTranslationalTransform(e){const t=[];return nonTranslationalTransformKeys.forEach((s=>{const r=e.getValue(s);void 0!==r&&(t.push([s,r.get()]),r.set(s.startsWith("scale")?1:0))})),t.length&&e.render(),t}const positionalValues={width:({x:e},{paddingLeft:t="0",paddingRight:s="0"})=>e.max-e.min-parseFloat(t)-parseFloat(s),height:({y:e},{paddingTop:t="0",paddingBottom:s="0"})=>e.max-e.min-parseFloat(t)-parseFloat(s),top:(e,{top:t})=>parseFloat(t),left:(e,{left:t})=>parseFloat(t),bottom:({y:e},{top:t})=>parseFloat(t)+(e.max-e.min),right:({x:e},{left:t})=>parseFloat(t)+(e.max-e.min),x:getTranslateFromMatrix(4,13),y:getTranslateFromMatrix(5,14)};positionalValues.translateX=positionalValues.x,positionalValues.translateY=positionalValues.y;const convertChangedValueTypes=(e,t,s)=>{const r=t.measureViewportBox(),a=t.current,n=getComputedStyle(a),{display:o}=n,i={};"none"===o&&t.setStaticValue("display",e.display||"block"),s.forEach((e=>{i[e]=positionalValues[e](r,n)})),t.render();const l=t.measureViewportBox();return s.forEach((s=>{const r=t.getValue(s);r&&r.jump(i[s]),e[s]=positionalValues[s](l,n)})),e},checkAndConvertChangedValueTypes=(e,t,s={},r={})=>{t={...t},r={...r};const a=Object.keys(t).filter(isPositionalKey);let n=[],o=!1;const i=[];if(a.forEach((a=>{const l=e.getValue(a);if(!e.hasValue(a))return;let m=s[a],p=findDimensionValueType(m);const u=t[a];let f;if(isKeyframesTarget(u)){const e=u.length,t=null===u[0]?1:0;m=u[t],p=findDimensionValueType(m);for(let s=t;s<e&&null!==u[s];s++)f?invariant(findDimensionValueType(u[s])===f,"All keyframes must be of the same type"):(f=findDimensionValueType(u[s]),invariant(f===p||isNumOrPxType(p)&&isNumOrPxType(f),"Keyframes must be of the same dimension as the current value"))}else f=findDimensionValueType(u);if(p!==f)if(isNumOrPxType(p)&&isNumOrPxType(f)){const e=l.get();"string"==typeof e&&l.set(parseFloat(e)),"string"==typeof u?t[a]=parseFloat(u):Array.isArray(u)&&f===px&&(t[a]=u.map(parseFloat))}else(null==p?void 0:p.transform)&&(null==f?void 0:f.transform)&&(0===m||0===u)?0===m?l.set(f.transform(m)):t[a]=p.transform(u):(o||(n=removeNonTranslationalTransform(e),o=!0),i.push(a),r[a]=void 0!==r[a]?r[a]:t[a],l.jump(u))})),i.length){const s=i.indexOf("height")>=0?window.pageYOffset:null,a=convertChangedValueTypes(t,e,i);return n.length&&n.forEach((([t,s])=>{e.getValue(t).set(s)})),e.render(),isBrowser&&null!==s&&window.scrollTo({top:s}),{target:a,transitionEnd:r}}return{target:t,transitionEnd:r}};function unitConversion(e,t,s,r){return hasPositionalKey(t)?checkAndConvertChangedValueTypes(e,t,s,r):{target:t,transitionEnd:r}}export{positionalValues,unitConversion};

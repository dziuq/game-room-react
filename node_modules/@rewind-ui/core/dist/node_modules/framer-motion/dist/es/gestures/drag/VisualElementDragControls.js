import{invariant}from"../../utils/errors.js";import{PanSession}from"../pan/PanSession.js";import{getGlobalLock}from"./utils/lock.js";import{isRefObject}from"../../utils/is-ref-object.js";import{addPointerEvent}from"../../events/add-pointer-event.js";import{applyConstraints,calcRelativeConstraints,resolveDragElastic,calcViewportConstraints,rebaseAxisConstraints,calcOrigin,defaultElastic}from"./utils/constraints.js";import{createBox}from"../../projection/geometry/models.js";import{eachAxis}from"../../projection/utils/each-axis.js";import{measurePageBox}from"../../projection/utils/measure.js";import{extractEventInfo}from"../../events/event-info.js";import{convertBoxToBoundingBox,convertBoundingBoxToBox}from"../../projection/geometry/conversion.js";import{addDomEvent}from"../../events/add-dom-event.js";import{calcLength}from"../../projection/geometry/delta-calc.js";import{mix}from"../../utils/mix.js";import{percent}from"../../value/types/numbers/units.js";import{animateMotionValue}from"../../animation/interfaces/motion-value.js";import{frame}from"../../frameloop/frame.js";const elementDragControls=new WeakMap;class VisualElementDragControls{constructor(t){this.openGlobalLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic=createBox(),this.visualElement=t}start(t,{snapToCursor:s=!1}={}){const{presenceContext:i}=this.visualElement;if(i&&!1===i.isPresent)return;this.panSession=new PanSession(t,{onSessionStart:t=>{this.stopAnimation(),s&&this.snapToCursor(extractEventInfo(t,"page").point)},onStart:(t,s)=>{const{drag:i,dragPropagation:n,onDragStart:o}=this.getProps();if(i&&!n&&(this.openGlobalLock&&this.openGlobalLock(),this.openGlobalLock=getGlobalLock(i),!this.openGlobalLock))return;this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),eachAxis((t=>{let s=this.getAxisMotionValue(t).get()||0;if(percent.test(s)){const{projection:i}=this.visualElement;if(i&&i.layout){const n=i.layout.layoutBox[t];if(n){s=calcLength(n)*(parseFloat(s)/100)}}}this.originPoint[t]=s})),o&&frame.update((()=>o(t,s)),!1,!0);const{animationState:e}=this.visualElement;e&&e.setActive("whileDrag",!0)},onMove:(t,s)=>{const{dragPropagation:i,dragDirectionLock:n,onDirectionLock:o,onDrag:e}=this.getProps();if(!i&&!this.openGlobalLock)return;const{offset:r}=s;if(n&&null===this.currentDirection)return this.currentDirection=getCurrentDirection(r),void(null!==this.currentDirection&&o&&o(this.currentDirection));this.updateAxis("x",s.point,r),this.updateAxis("y",s.point,r),this.visualElement.render(),e&&e(t,s)},onSessionEnd:(t,s)=>this.stop(t,s)},{transformPagePoint:this.visualElement.getTransformPagePoint()})}stop(t,s){const i=this.isDragging;if(this.cancel(),!i)return;const{velocity:n}=s;this.startAnimation(n);const{onDragEnd:o}=this.getProps();o&&frame.update((()=>o(t,s)))}cancel(){this.isDragging=!1;const{projection:t,animationState:s}=this.visualElement;t&&(t.isAnimationBlocked=!1),this.panSession&&this.panSession.end(),this.panSession=void 0;const{dragPropagation:i}=this.getProps();!i&&this.openGlobalLock&&(this.openGlobalLock(),this.openGlobalLock=null),s&&s.setActive("whileDrag",!1)}updateAxis(t,s,i){const{drag:n}=this.getProps();if(!i||!shouldDrag(t,n,this.currentDirection))return;const o=this.getAxisMotionValue(t);let e=this.originPoint[t]+i[t];this.constraints&&this.constraints[t]&&(e=applyConstraints(e,this.constraints[t],this.elastic[t])),o.set(e)}resolveConstraints(){const{dragConstraints:t,dragElastic:s}=this.getProps(),{layout:i}=this.visualElement.projection||{},n=this.constraints;t&&isRefObject(t)?this.constraints||(this.constraints=this.resolveRefConstraints()):this.constraints=!(!t||!i)&&calcRelativeConstraints(i.layoutBox,t),this.elastic=resolveDragElastic(s),n!==this.constraints&&i&&this.constraints&&!this.hasMutatedConstraints&&eachAxis((t=>{this.getAxisMotionValue(t)&&(this.constraints[t]=rebaseAxisConstraints(i.layoutBox[t],this.constraints[t]))}))}resolveRefConstraints(){const{dragConstraints:t,onMeasureDragConstraints:s}=this.getProps();if(!t||!isRefObject(t))return!1;const i=t.current;invariant(null!==i,"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");const{projection:n}=this.visualElement;if(!n||!n.layout)return!1;const o=measurePageBox(i,n.root,this.visualElement.getTransformPagePoint());let e=calcViewportConstraints(n.layout.layoutBox,o);if(s){const t=s(convertBoxToBoundingBox(e));this.hasMutatedConstraints=!!t,t&&(e=convertBoundingBoxToBox(t))}return e}startAnimation(t){const{drag:s,dragMomentum:i,dragElastic:n,dragTransition:o,dragSnapToOrigin:e,onDragTransitionEnd:r}=this.getProps(),a=this.constraints||{},l=eachAxis((r=>{if(!shouldDrag(r,s,this.currentDirection))return;let l=a&&a[r]||{};e&&(l={min:0,max:0});const c=n?200:1e6,u=n?40:1e7,h={type:"inertia",velocity:i?t[r]:0,bounceStiffness:c,bounceDamping:u,timeConstant:750,restDelta:1,restSpeed:10,...o,...l};return this.startAxisValueAnimation(r,h)}));return Promise.all(l).then(r)}startAxisValueAnimation(t,s){const i=this.getAxisMotionValue(t);return i.start(animateMotionValue(t,i,0,s))}stopAnimation(){eachAxis((t=>this.getAxisMotionValue(t).stop()))}getAxisMotionValue(t){const s="_drag"+t.toUpperCase(),i=this.visualElement.getProps(),n=i[s];return n||this.visualElement.getValue(t,(i.initial?i.initial[t]:void 0)||0)}snapToCursor(t){eachAxis((s=>{const{drag:i}=this.getProps();if(!shouldDrag(s,i,this.currentDirection))return;const{projection:n}=this.visualElement,o=this.getAxisMotionValue(s);if(n&&n.layout){const{min:i,max:e}=n.layout.layoutBox[s];o.set(t[s]-mix(i,e,.5))}}))}scalePositionWithinConstraints(){if(!this.visualElement.current)return;const{drag:t,dragConstraints:s}=this.getProps(),{projection:i}=this.visualElement;if(!isRefObject(s)||!i||!this.constraints)return;this.stopAnimation();const n={x:0,y:0};eachAxis((t=>{const s=this.getAxisMotionValue(t);if(s){const i=s.get();n[t]=calcOrigin({min:i,max:i},this.constraints[t])}}));const{transformTemplate:o}=this.visualElement.getProps();this.visualElement.current.style.transform=o?o({},""):"none",i.root&&i.root.updateScroll(),i.updateLayout(),this.resolveConstraints(),eachAxis((s=>{if(!shouldDrag(s,t,null))return;const i=this.getAxisMotionValue(s),{min:o,max:e}=this.constraints[s];i.set(mix(o,e,n[s]))}))}addListeners(){if(!this.visualElement.current)return;elementDragControls.set(this.visualElement,this);const t=this.visualElement.current,s=addPointerEvent(t,"pointerdown",(t=>{const{drag:s,dragListener:i=!0}=this.getProps();s&&i&&this.start(t)})),i=()=>{const{dragConstraints:t}=this.getProps();isRefObject(t)&&(this.constraints=this.resolveRefConstraints())},{projection:n}=this.visualElement,o=n.addEventListener("measure",i);n&&!n.layout&&(n.root&&n.root.updateScroll(),n.updateLayout()),i();const e=addDomEvent(window,"resize",(()=>this.scalePositionWithinConstraints())),r=n.addEventListener("didUpdate",(({delta:t,hasLayoutChanged:s})=>{this.isDragging&&s&&(eachAxis((s=>{const i=this.getAxisMotionValue(s);i&&(this.originPoint[s]+=t[s].translate,i.set(i.get()+t[s].translate))})),this.visualElement.render())}));return()=>{e(),s(),o(),r&&r()}}getProps(){const t=this.visualElement.getProps(),{drag:s=!1,dragDirectionLock:i=!1,dragPropagation:n=!1,dragConstraints:o=!1,dragElastic:e=defaultElastic,dragMomentum:r=!0}=t;return{...t,drag:s,dragDirectionLock:i,dragPropagation:n,dragConstraints:o,dragElastic:e,dragMomentum:r}}}function shouldDrag(t,s,i){return!(!0!==s&&s!==t||null!==i&&i!==t)}function getCurrentDirection(t,s=10){let i=null;return Math.abs(t.y)>s?i="y":Math.abs(t.x)>s&&(i="x"),i}export{VisualElementDragControls,elementDragControls};

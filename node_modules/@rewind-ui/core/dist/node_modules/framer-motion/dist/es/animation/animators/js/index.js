import{keyframes}from"../../generators/keyframes.js";import{spring}from"../../generators/spring/index.js";import{inertia}from"../../generators/inertia.js";import{frameloopDriver}from"./driver-frameloop.js";import{interpolate}from"../../../utils/interpolate.js";import{clamp}from"../../../utils/clamp.js";import{millisecondsToSeconds,secondsToMilliseconds}from"../../../utils/time-conversion.js";import{calcGeneratorDuration}from"../../generators/utils/calc-duration.js";const types={decay:inertia,inertia:inertia,tween:keyframes,keyframes:keyframes,spring:spring};function animateValue({autoplay:e=!0,delay:t=0,driver:n=frameloopDriver,keyframes:r,type:l="keyframes",repeat:o=0,repeatDelay:i=0,repeatType:a="loop",onPlay:s,onStop:u,onComplete:c,onUpdate:m,...p}){let d,f,y=1,v=!1;const g=()=>{f=new Promise((e=>{d=e}))};let h;g();const k=types[l]||keyframes;let D;k!==keyframes&&"number"!=typeof r[0]&&(D=interpolate([0,100],r,{clamp:!1}),r=[0,100]);const j=k({...p,keyframes:r});let M;"mirror"===a&&(M=k({...p,keyframes:[...r].reverse(),velocity:-(p.velocity||0)}));let T="idle",S=null,w=null,x=null;null===j.calculatedDuration&&o&&(j.calculatedDuration=calcGeneratorDuration(j));const{calculatedDuration:G}=j;let P=1/0,V=1/0;null!==G&&(P=G+i,V=P*(o+1)-i);let b=0;const B=e=>{if(null===w)return;y>0&&(w=Math.min(w,e)),y<0&&(w=Math.min(e-V/y,w)),b=null!==S?S:Math.round(e-w)*y;const n=b-t*(y>=0?1:-1),l=y>=0?n<0:n>V;b=Math.max(n,0),"finished"===T&&null===S&&(b=V);let s=b,u=j;if(o){const e=b/P;let t=Math.floor(e),n=e%1;!n&&e>=1&&(n=1),1===n&&t--,t=Math.min(t,o+1);const r=Boolean(t%2);r&&("reverse"===a?(n=1-n,i&&(n-=i/P)):"mirror"===a&&(u=M));let l=clamp(0,1,n);b>V&&(l="reverse"===a&&r?1:0),s=l*P}const c=l?{done:!1,value:r[0]}:u.next(s);D&&(c.value=D(c.value));let{done:p}=c;l||null===G||(p=y>=0?b>=V:b<=0);const d=null===S&&("finished"===T||"running"===T&&p);return m&&m(c.value),d&&q(),c},C=()=>{h&&h.stop(),h=void 0},U=()=>{T="idle",C(),d(),g(),w=x=null},q=()=>{T="finished",c&&c(),C(),d()},z=()=>{if(v)return;h||(h=n(B));const e=h.now();s&&s(),null!==S?w=e-S:w&&"finished"!==T||(w=e),"finished"===T&&g(),x=w,S=null,T="running",h.start()};e&&z();const A={then:(e,t)=>f.then(e,t),get time(){return millisecondsToSeconds(b)},set time(e){e=secondsToMilliseconds(e),b=e,null===S&&h&&0!==y?w=h.now()-e/y:S=e},get duration(){const e=null===j.calculatedDuration?calcGeneratorDuration(j):j.calculatedDuration;return millisecondsToSeconds(e)},get speed(){return y},set speed(e){e!==y&&h&&(y=e,A.time=millisecondsToSeconds(b))},get state(){return T},play:z,pause:()=>{T="paused",S=b},stop:()=>{v=!0,"idle"!==T&&(T="idle",u&&u(),U())},cancel:()=>{null!==x&&B(x),U()},complete:()=>{T="finished"},sample:e=>(w=0,B(e))};return A}export{animateValue};

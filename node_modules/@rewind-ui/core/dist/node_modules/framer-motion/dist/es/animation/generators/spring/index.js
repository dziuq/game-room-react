import{millisecondsToSeconds}from"../../../utils/time-conversion.js";import{calcGeneratorVelocity}from"../utils/velocity.js";import{findSpring,calcAngularFreq}from"./find.js";const durationKeys=["duration","bounce"],physicsKeys=["stiffness","damping","mass"];function isSpringType(s,e){return e.some((e=>void 0!==s[e]))}function getSpringOptions(s){let e={velocity:0,stiffness:100,damping:10,mass:1,isResolvedFromDuration:!1,...s};if(!isSpringType(s,physicsKeys)&&isSpringType(s,durationKeys)){const t=findSpring(s);e={...e,...t,velocity:0,mass:1},e.isResolvedFromDuration=!0}return e}function spring({keyframes:s,restDelta:e,restSpeed:t,...n}){const i=s[0],o=s[s.length-1],r={done:!1,value:i},{stiffness:a,damping:c,mass:l,velocity:p,duration:d,isResolvedFromDuration:u}=getSpringOptions(n),m=p?-millisecondsToSeconds(p):0,f=c/(2*Math.sqrt(a*l)),h=o-i,g=millisecondsToSeconds(Math.sqrt(a/l)),y=Math.abs(h)<5;let M;if(t||(t=y?.01:2),e||(e=y?.005:.5),f<1){const s=calcAngularFreq(g,f);M=e=>{const t=Math.exp(-f*g*e);return o-t*((m+f*g*h)/s*Math.sin(s*e)+h*Math.cos(s*e))}}else if(1===f)M=s=>o-Math.exp(-g*s)*(h+(m+g*h)*s);else{const s=g*Math.sqrt(f*f-1);M=e=>{const t=Math.exp(-f*g*e),n=Math.min(s*e,300);return o-t*((m+f*g*h)*Math.sinh(n)+s*h*Math.cosh(n))/s}}return{calculatedDuration:u&&d||null,next:s=>{const n=M(s);if(u)r.done=s>=d;else{let i=m;0!==s&&(i=f<1?calcGeneratorVelocity(M,s,n):0);const a=Math.abs(i)<=t,c=Math.abs(o-n)<=e;r.done=a&&c}return r.value=r.done?o:n,r}}}export{spring};

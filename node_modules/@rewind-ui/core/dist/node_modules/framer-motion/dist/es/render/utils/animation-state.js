import{isAnimationControls}from"../../animation/utils/is-animation-controls.js";import{isKeyframesTarget}from"../../animation/utils/is-keyframes-target.js";import{shallowCompare}from"../../utils/shallow-compare.js";import{isVariantLabel}from"./is-variant-label.js";import{resolveVariant}from"./resolve-dynamic-variants.js";import{variantPriorityOrder}from"./variant-props.js";import{animateVisualElement}from"../../animation/interfaces/visual-element.js";const reversePriorityOrder=[...variantPriorityOrder].reverse(),numAnimationTypes=variantPriorityOrder.length;function animateList(e){return t=>Promise.all(t.map((({animation:t,options:i})=>animateVisualElement(e,t,i))))}function createAnimationState(e){let t=animateList(e);const i=createState();let a=!0;const r=(t,i)=>{const a=resolveVariant(e,i);if(a){const{transition:e,transitionEnd:i,...r}=a;t={...t,...r,...i}}return t};function n(n,o){const s=e.getProps(),l=e.getVariantContext(!0)||{},c=[],m=new Set;let p={},v=1/0;for(let t=0;t<numAnimationTypes;t++){const u=reversePriorityOrder[t],y=i[u],d=void 0!==s[u]?s[u]:l[u],f=isVariantLabel(d),h=u===o?y.isActive:null;!1===h&&(v=t);let A=d===l[u]&&d!==s[u]&&f;if(A&&a&&e.manuallyAnimateOnMount&&(A=!1),y.protectedKeys={...p},!y.isActive&&null===h||!d&&!y.prevProp||isAnimationControls(d)||"boolean"==typeof d)continue;const g=checkVariantsDidChange(y.prevProp,d);let S=g||u===o&&y.isActive&&!A&&f||t>v&&f;const T=Array.isArray(d)?d:[d];let V=T.reduce(r,{});!1===h&&(V={});const{prevResolvedValues:P={}}=y,w={...P,...V},C=e=>{S=!0,m.delete(e),y.needsAnimating[e]=!0};for(const e in w){const t=V[e],i=P[e];p.hasOwnProperty(e)||(t!==i?isKeyframesTarget(t)&&isKeyframesTarget(i)?!shallowCompare(t,i)||g?C(e):y.protectedKeys[e]=!0:void 0!==t?C(e):m.add(e):void 0!==t&&m.has(e)?C(e):y.protectedKeys[e]=!0)}y.prevProp=d,y.prevResolvedValues=V,y.isActive&&(p={...p,...V}),a&&e.blockInitialAnimation&&(S=!1),S&&!A&&c.push(...T.map((e=>({animation:e,options:{type:u,...n}}))))}if(m.size){const t={};m.forEach((i=>{const a=e.getBaseTarget(i);void 0!==a&&(t[i]=a)})),c.push({animation:t})}let u=Boolean(c.length);return a&&!1===s.initial&&!e.manuallyAnimateOnMount&&(u=!1),a=!1,u?t(c):Promise.resolve()}return{animateChanges:n,setActive:function(t,a,r){var o;if(i[t].isActive===a)return Promise.resolve();null===(o=e.variantChildren)||void 0===o||o.forEach((e=>{var i;return null===(i=e.animationState)||void 0===i?void 0:i.setActive(t,a)})),i[t].isActive=a;const s=n(r,t);for(const e in i)i[e].protectedKeys={};return s},setAnimateFunction:function(i){t=i(e)},getState:()=>i}}function checkVariantsDidChange(e,t){return"string"==typeof t?t!==e:!!Array.isArray(t)&&!shallowCompare(t,e)}function createTypeState(e=!1){return{isActive:e,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function createState(){return{animate:createTypeState(!0),whileInView:createTypeState(),whileHover:createTypeState(),whileTap:createTypeState(),whileDrag:createTypeState(),whileFocus:createTypeState(),exit:createTypeState()}}export{checkVariantsDidChange,createAnimationState};

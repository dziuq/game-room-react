"use strict";var mix=require("./mix.cjs"),mixColor=require("./mix-color.cjs"),pipe=require("./pipe.cjs"),errors=require("./errors.cjs"),index$1=require("../value/types/color/index.cjs"),index=require("../value/types/complex/index.cjs");const mixImmediate=(e,r)=>i=>`${i>0?r:e}`;function getMixer(e,r){return"number"==typeof e?i=>mix.mix(e,r,i):index$1.color.test(e)?mixColor.mixColor(e,r):e.startsWith("var(")?mixImmediate(e,r):mixComplex(e,r)}const mixArray=(e,r)=>{const i=[...e],o=i.length,t=e.map(((e,i)=>getMixer(e,r[i])));return e=>{for(let r=0;r<o;r++)i[r]=t[r](e);return i}},mixObject=(e,r)=>{const i={...e,...r},o={};for(const t in i)void 0!==e[t]&&void 0!==r[t]&&(o[t]=getMixer(e[t],r[t]));return e=>{for(const r in o)i[r]=o[r](e);return i}},mixComplex=(e,r)=>{const i=index.complex.createTransformer(r),o=index.analyseComplexValue(e),t=index.analyseComplexValue(r);return o.numVars===t.numVars&&o.numColors===t.numColors&&o.numNumbers>=t.numNumbers?pipe.pipe(mixArray(o.values,t.values),i):(errors.warning(!0,`Complex values '${e}' and '${r}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`),mixImmediate(e,r))};exports.mixArray=mixArray,exports.mixComplex=mixComplex,exports.mixObject=mixObject;

"use strict";var isAnimationControls=require("../../animation/utils/is-animation-controls.cjs"),isKeyframesTarget=require("../../animation/utils/is-keyframes-target.cjs"),shallowCompare=require("../../utils/shallow-compare.cjs"),isVariantLabel=require("./is-variant-label.cjs"),resolveDynamicVariants=require("./resolve-dynamic-variants.cjs"),variantProps=require("./variant-props.cjs"),visualElement=require("../../animation/interfaces/visual-element.cjs");const reversePriorityOrder=[...variantProps.variantPriorityOrder].reverse(),numAnimationTypes=variantProps.variantPriorityOrder.length;function animateList(e){return t=>Promise.all(t.map((({animation:t,options:a})=>visualElement.animateVisualElement(e,t,a))))}function createAnimationState(e){let t=animateList(e);const a=createState();let i=!0;const r=(t,a)=>{const i=resolveDynamicVariants.resolveVariant(e,a);if(i){const{transition:e,transitionEnd:a,...r}=i;t={...t,...r,...a}}return t};function n(n,s){const o=e.getProps(),c=e.getVariantContext(!0)||{},l=[],m=new Set;let u={},v=1/0;for(let t=0;t<numAnimationTypes;t++){const p=reversePriorityOrder[t],y=a[p],d=void 0!==o[p]?o[p]:c[p],h=isVariantLabel.isVariantLabel(d),A=p===s?y.isActive:null;!1===A&&(v=t);let f=d===c[p]&&d!==o[p]&&h;if(f&&i&&e.manuallyAnimateOnMount&&(f=!1),y.protectedKeys={...u},!y.isActive&&null===A||!d&&!y.prevProp||isAnimationControls.isAnimationControls(d)||"boolean"==typeof d)continue;const g=checkVariantsDidChange(y.prevProp,d);let T=g||p===s&&y.isActive&&!f&&h||t>v&&h;const S=Array.isArray(d)?d:[d];let V=S.reduce(r,{});!1===A&&(V={});const{prevResolvedValues:C={}}=y,P={...C,...V},w=e=>{T=!0,m.delete(e),y.needsAnimating[e]=!0};for(const e in P){const t=V[e],a=C[e];u.hasOwnProperty(e)||(t!==a?isKeyframesTarget.isKeyframesTarget(t)&&isKeyframesTarget.isKeyframesTarget(a)?!shallowCompare.shallowCompare(t,a)||g?w(e):y.protectedKeys[e]=!0:void 0!==t?w(e):m.add(e):void 0!==t&&m.has(e)?w(e):y.protectedKeys[e]=!0)}y.prevProp=d,y.prevResolvedValues=V,y.isActive&&(u={...u,...V}),i&&e.blockInitialAnimation&&(T=!1),T&&!f&&l.push(...S.map((e=>({animation:e,options:{type:p,...n}}))))}if(m.size){const t={};m.forEach((a=>{const i=e.getBaseTarget(a);void 0!==i&&(t[a]=i)})),l.push({animation:t})}let p=Boolean(l.length);return i&&!1===o.initial&&!e.manuallyAnimateOnMount&&(p=!1),i=!1,p?t(l):Promise.resolve()}return{animateChanges:n,setActive:function(t,i,r){var s;if(a[t].isActive===i)return Promise.resolve();null===(s=e.variantChildren)||void 0===s||s.forEach((e=>{var a;return null===(a=e.animationState)||void 0===a?void 0:a.setActive(t,i)})),a[t].isActive=i;const o=n(r,t);for(const e in a)a[e].protectedKeys={};return o},setAnimateFunction:function(a){t=a(e)},getState:()=>a}}function checkVariantsDidChange(e,t){return"string"==typeof t?t!==e:!!Array.isArray(t)&&!shallowCompare.shallowCompare(t,e)}function createTypeState(e=!1){return{isActive:e,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function createState(){return{animate:createTypeState(!0),whileInView:createTypeState(),whileHover:createTypeState(),whileTap:createTypeState(),whileDrag:createTypeState(),whileFocus:createTypeState(),exit:createTypeState()}}exports.checkVariantsDidChange=checkVariantsDidChange,exports.createAnimationState=createAnimationState;

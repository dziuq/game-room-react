"use strict";var React=require("react"),useForceUpdate=require("../../utils/use-force-update.cjs"),useIsMounted=require("../../utils/use-is-mounted.cjs"),PresenceChild=require("./PresenceChild.cjs"),LayoutGroupContext=require("../../context/LayoutGroupContext.cjs"),useIsomorphicEffect=require("../../utils/use-isomorphic-effect.cjs"),useUnmountEffect=require("../../utils/use-unmount-effect.cjs"),errors=require("../../utils/errors.cjs");function _interopNamespaceDefault(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,Object.freeze(t)}var React__namespace=_interopNamespaceDefault(React);const getChildKey=e=>e.key||"";function updateChildLookup(e,t){e.forEach((e=>{const n=getChildKey(e);t.set(n,e)}))}function onlyElements(e){const t=[];return React.Children.forEach(e,(e=>{React.isValidElement(e)&&t.push(e)})),t}const AnimatePresence=({children:e,custom:t,initial:n=!0,onExitComplete:r,exitBeforeEnter:c,presenceAffectsLayout:s=!0,mode:a="sync"})=>{errors.invariant(!c,"Replace exitBeforeEnter with mode='wait'");const o=React.useContext(LayoutGroupContext.LayoutGroupContext).forceRender||useForceUpdate.useForceUpdate()[0],i=useIsMounted.useIsMounted(),u=onlyElements(e);let l=u;const f=React.useRef(new Map).current,d=React.useRef(l),m=React.useRef(new Map).current,p=React.useRef(!0);if(useIsomorphicEffect.useIsomorphicLayoutEffect((()=>{p.current=!1,updateChildLookup(u,m),d.current=l})),useUnmountEffect.useUnmountEffect((()=>{p.current=!0,m.clear(),f.clear()})),p.current)return React__namespace.createElement(React__namespace.Fragment,null,l.map((e=>React__namespace.createElement(PresenceChild.PresenceChild,{key:getChildKey(e),isPresent:!0,initial:!!n&&void 0,presenceAffectsLayout:s,mode:a},e))));l=[...l];const h=d.current.map(getChildKey),y=u.map(getChildKey),C=h.length;for(let e=0;e<C;e++){const t=h[e];-1!==y.indexOf(t)||f.has(t)||f.set(t,void 0)}return"wait"===a&&f.size&&(l=[]),f.forEach(((e,n)=>{if(-1!==y.indexOf(n))return;const c=m.get(n);if(!c)return;const p=h.indexOf(n);let C=e;if(!C){const e=()=>{m.delete(n),f.delete(n);const e=d.current.findIndex((e=>e.key===n));if(d.current.splice(e,1),!f.size){if(d.current=u,!1===i.current)return;o(),r&&r()}};C=React__namespace.createElement(PresenceChild.PresenceChild,{key:getChildKey(c),isPresent:!1,onExitComplete:e,custom:t,presenceAffectsLayout:s,mode:a},c),f.set(n,C)}l.splice(p,0,C)})),l=l.map((e=>{const t=e.key;return f.has(t)?e:React__namespace.createElement(PresenceChild.PresenceChild,{key:getChildKey(e),isPresent:!0,presenceAffectsLayout:s,mode:a},e)})),"production"!==process.env.NODE_ENV&&"wait"===a&&l.length>1&&console.warn('You\'re attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.'),React__namespace.createElement(React__namespace.Fragment,null,f.size?l:l.map((e=>React.cloneElement(e))))};exports.AnimatePresence=AnimatePresence;

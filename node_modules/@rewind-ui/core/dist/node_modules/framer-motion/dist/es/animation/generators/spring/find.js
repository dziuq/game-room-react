import{warning}from"../../../utils/errors.js";import{clamp}from"../../../utils/clamp.js";import{secondsToMilliseconds,millisecondsToSeconds}from"../../../utils/time-conversion.js";const safeMin=.001,minDuration=.01,maxDuration=10,minDamping=.05,maxDamping=1;function findSpring({duration:n=800,bounce:o=.25,velocity:t=0,mass:i=1}){let r,a;warning(n<=secondsToMilliseconds(10),"Spring duration must be 10 seconds or less");let s=1-o;s=clamp(.05,1,s),n=clamp(.01,10,millisecondsToSeconds(n)),s<1?(r=o=>{const i=o*s,r=i*n;return.001-(i-t)/calcAngularFreq(o,s)*Math.exp(-r)},a=o=>{const i=o*s*n,a=i*t+t,e=Math.pow(s,2)*Math.pow(o,2)*n,c=Math.exp(-i),l=calcAngularFreq(Math.pow(o,2),s);return(.001-r(o)>0?-1:1)*((a-e)*c)/l}):(r=o=>Math.exp(-o*n)*((o-t)*n+1)-.001,a=o=>Math.exp(-o*n)*(n*n*(t-o)));const e=approximateRoot(r,a,5/n);if(n=secondsToMilliseconds(n),isNaN(e))return{stiffness:100,damping:10,duration:n};{const o=Math.pow(e,2)*i;return{stiffness:o,damping:2*s*Math.sqrt(i*o),duration:n}}}const rootIterations=12;function approximateRoot(n,o,t){let i=t;for(let t=1;t<rootIterations;t++)i-=n(i)/o(i);return i}function calcAngularFreq(n,o){return n*Math.sqrt(1-o*o)}export{calcAngularFreq,findSpring,maxDamping,maxDuration,minDamping,minDuration};
